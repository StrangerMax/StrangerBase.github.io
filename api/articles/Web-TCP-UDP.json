{"title":"计算机网络-TCP","uid":"fc6990bffcc48d5be11a6070827fa5e5","slug":"Web-TCP-UDP","date":"2022-06-05T10:44:37.000Z","updated":"2022-06-05T14:06:33.738Z","comments":true,"path":"api/articles/Web-TCP-UDP.json","keywords":null,"cover":"http://up.36992.com/pic/e6/c5/51/e6c551e768092c8655292d89a4034a74.jpg","content":"<p><a href=\"https://blog.csdn.net/qzcsu/article/details/72861891\">本文内容参考链接</a></p>\n<h1 id=\"TCP报文内容\"><a href=\"#TCP报文内容\" class=\"headerlink\" title=\"TCP报文内容\"></a>TCP报文内容</h1><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/12401022/1651504239677-00c99f89-b43a-4056-90a2-38e77ff7fc2c.png?x-oss-process=image/resize,w_708,limit_0\" alt=\"TCP\"></p>\n<h1 id=\"TCP-三次握手\"><a href=\"#TCP-三次握手\" class=\"headerlink\" title=\"TCP 三次握手\"></a>TCP 三次握手</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/14833822-b0e804173e25e972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/966/format/webp\" alt=\"TCP-3\"></p>\n<p>三次握手过程</p>\n<ul>\n<li>客户端–发送带有 SYN 标志的数据包–⼀次握⼿–服务端</li>\n<li>服务端–发送带有 SYN&#x2F;ACK 标志的数据包–⼆次握⼿–客户端</li>\n<li>客户端–发送带有带有 ACK 标志的数据包–三次握⼿–服务端</li>\n</ul>\n<p>其中：</p>\n<ul>\n<li>SYN：<strong>同步标志</strong> 同步序列编号(Synchronize Sequence Numbers)栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。</li>\n<li>ACK：<strong>确认标志</strong> 确认编号(Acknowledgement Number)栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号(w+1，Figure-1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。</li>\n</ul>\n<h2 id=\"为什么要进行三次握手\"><a href=\"#为什么要进行三次握手\" class=\"headerlink\" title=\"为什么要进行三次握手\"></a>为什么要进行三次握手</h2><p>即为什么不能用两次握手进行连接：</p>\n<ul>\n<li>三次握手的⽬的是建⽴可靠的通信信道，通信即数据的发送与接收，⽽三次握手最主要的⽬的就是<strong>双方确认自己与对方的发送与接收是正常的</strong>。</li>\n<li>改成仅需要两次握手，死锁是可能发生的<ul>\n<li>考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组，会导致形成死锁。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如果已经建立了连接，但是客户端突然出现故障了怎么办\"><a href=\"#如果已经建立了连接，但是客户端突然出现故障了怎么办\" class=\"headerlink\" title=\"如果已经建立了连接，但是客户端突然出现故障了怎么办\"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h2><p>​\t\tTCP设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，<strong>时间通常是设置为2小时</strong>，若两小时还没有收到客户端的任何数据，服务器就会<strong>发送一个探测报文段</strong>，以后每隔<strong>75秒钟</strong>发送一次。若一<strong>连发送10个</strong>探测报文仍然没反应，服务器就认为客户端出了故障，就会关闭连接。</p>\n<h2 id=\"为什么要传回-SYN\"><a href=\"#为什么要传回-SYN\" class=\"headerlink\" title=\"为什么要传回 SYN\"></a>为什么要传回 SYN</h2><p>​\t\t接收端传回发送端所发送的 SYN 是为了告诉发送端，接收端接收到的信息确实为发送端所发送的信号。</p>\n<h2 id=\"传了-SYN-为啥还要传-ACK\"><a href=\"#传了-SYN-为啥还要传-ACK\" class=\"headerlink\" title=\"传了 SYN,为啥还要传 ACK\"></a>传了 SYN,为啥还要传 ACK</h2><p>​\t\t双⽅通信⽆误必须是两者互相发送信息都⽆误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号进行验证。</p>\n<h1 id=\"TCP-四次挥手\"><a href=\"#TCP-四次挥手\" class=\"headerlink\" title=\"TCP 四次挥手\"></a>TCP 四次挥手</h1><p><img src=\"https://img4.sycdn.imooc.com/5c063d630001815e11720676.jpg\" alt=\"四次挥手\"></p>\n<p>四次挥手过程：</p>\n<ul>\n<li><p>客户端-发送⼀个 FIN，⽤来<strong>关闭客户端到服务器的数据传送</strong></p>\n</li>\n<li><p>服务器-收到这个 FIN，它返回一个 <strong>ACK</strong>，确认序号为收到的<strong>序号加1</strong> 。和 SYN⼀样，⼀个FIN将占⽤⼀个序号</p>\n</li>\n<li><p>服务器-<strong>关闭与客户端的连接</strong>，发送⼀个<strong>FIN</strong>给客户端</p>\n</li>\n<li><p>客户端-发回 <strong>ACK</strong> 报⽂确认，并将确认序号设置为收到<strong>序号加1</strong></p>\n<ul>\n<li><p><strong>FIN：结束标志</strong></p>\n<p>带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据三次握手Three-way Handshake</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"为什么建立连接是三次握手，关闭连接确是四次挥手？\"><a href=\"#为什么建立连接是三次握手，关闭连接确是四次挥手？\" class=\"headerlink\" title=\"为什么建立连接是三次握手，关闭连接确是四次挥手？\"></a>为什么建立连接是三次握手，关闭连接确是四次挥手？</h2><ul>\n<li>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</li>\n<li>而关闭连接时，服务器收到对方的FIN报文时，<strong>仅表示对方不再发送数据</strong>,但<strong>还能接收数据</strong>，而自己也<strong>未必全部数据都发送给对方</strong>了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方<strong>ACK和FIN一般都会分开发送</strong>，从而导致多了一次。</li>\n</ul>\n<h2 id=\"为什么TIME-WAIT状态需要经过2MSL才返回到CLOSE状态\"><a href=\"#为什么TIME-WAIT状态需要经过2MSL才返回到CLOSE状态\" class=\"headerlink\" title=\"为什么TIME_WAIT状态需要经过2MSL才返回到CLOSE状态\"></a>为什么TIME_WAIT状态需要经过2MSL才返回到CLOSE状态</h2><ul>\n<li>TIME_WAIT状态用来重发可能丢失的ACK报文<ul>\n<li>四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的：在Client发送出最后的ACK回复后，该<strong>ACK可能丢失</strong>。Server如果没有收到ACK，将不断重复发送FIN片段，所以Client不能立即关闭，它必须确认Server接收到了该ACK。</li>\n<li>Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL</li>\n</ul>\n</li>\n<li>MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则可结束TCP连接。</li>\n</ul>\n<h1 id=\"TCP协议如何保证可靠传输\"><a href=\"#TCP协议如何保证可靠传输\" class=\"headerlink\" title=\"TCP协议如何保证可靠传输\"></a>TCP协议如何保证可靠传输</h1><p>TCP主要靠以下相关机制保证其可靠传输：</p>\n<ul>\n<li><strong>TCP分段</strong>：应用数据被分割成合适的TCP段发送（对UDP来说，应用程序产生的数据段长度将保持不变）</li>\n<li><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停止发送，等待对方确认。在收到确认后再发下⼀个分组<ul>\n<li><strong>超时重传</strong>：每发出一个TCP段都会启动一个”重传定时器”；如果不能及时收到一个确认，将重传这个报文段</li>\n</ul>\n</li>\n<li><strong>流量控制</strong>：缓冲区固定大小，TCP接收端只允许另一端发送接收缓冲区所能接纳的数据（滑动窗口）</li>\n<li><strong>数据校验</strong>：TCP首部(校验和)；如果收到段的校验和有差错，会选择丢弃和不确认</li>\n<li><strong>拥塞控制</strong>： 当网络拥塞时，减少数据的发送</li>\n<li><strong>处理数据包</strong>：a) 丢弃重复的数据包；b) 将失序的数据包重新排序后交</li>\n</ul>\n<h2 id=\"TCP分段\"><a href=\"#TCP分段\" class=\"headerlink\" title=\"TCP分段\"></a>TCP分段</h2><ul>\n<li>应用数据被分割成 TCP 认为最适合发送的数据块</li>\n<li>TCP 给发送的每⼀个包进行编号，接收方对数据包进行排序，把有序数据传送给应⽤层</li>\n<li>TCP 的接收端会丢弃重复的数据</li>\n</ul>\n<h2 id=\"ARQ协议\"><a href=\"#ARQ协议\" class=\"headerlink\" title=\"ARQ协议\"></a>ARQ协议</h2><ul>\n<li>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中<strong>数据链路层和传输层</strong>的错误纠正协议之⼀。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。<ul>\n<li>停止等待ARQ协议（<strong>超时重传</strong>）<ul>\n<li>确认丢失：发送端重传消息，接收端丢弃重复消息，不向上层交付，重发确认ACK</li>\n<li>确认迟到：发送端重传消息，接收端丢弃重复消息，重发确认ACK；发送端收到重复确认丢弃第二次ACK(确认通知实际为第一次的ACK)</li>\n</ul>\n</li>\n<li>连续ARQ协议<ul>\n<li>Go-Back-N: 第N条丢失，其之后的无论是否丢失都要重传</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"滑动窗口-流量控制\"><a href=\"#滑动窗口-流量控制\" class=\"headerlink\" title=\"滑动窗口-流量控制\"></a>滑动窗口-流量控制</h2><p>TCP 利用<strong>滑动窗口</strong>实现<strong>流量控制</strong>。</p>\n<ul>\n<li><strong>流量控制</strong>是为了<strong>控制发送方发送速率</strong>，保证接收方来得及接收。</li>\n<li>接收方发送的确认报文中的<strong>窗口字段</strong>可以用来<strong>控制</strong>发送方窗口大小，从而影响发送方的发送速率<ul>\n<li>将窗口字段设置为 0，则发送方不能发送数据</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a><strong>拥塞控制</strong></h2><ul>\n<li>拥塞：<ul>\n<li>在某段时间，对网络中某⼀资源需求超过了该资源所能提供的可用部分，网络的性能将变坏</li>\n</ul>\n</li>\n<li>拥塞控制：<ul>\n<li>防止过多的数据注⼊到网络中，这样就可以使网络中的路由器或链路不致过载。</li>\n<li><strong>前提：</strong>网络能够承受现有的网络负荷</li>\n<li>拥塞控制是⼀个<strong>全局性</strong>的过程，涉及到所有的<strong>主机</strong>，所有的<strong>路由器</strong>，以及与<strong>降低⽹络传输性能</strong>有关的<strong>所有因素</strong>。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是<strong>抑制</strong>发送端发送数据的速率，以便接收端来得及接收。</li>\n<li><strong>拥塞窗口（cwnd）</strong>：拥塞控制窗口的<strong>大小</strong>取决于网络的<strong>拥塞程度</strong>，并且<strong>动态变化</strong>。发送方让自己的发送窗⼝取为拥塞窗口和接收方的接受窗口中较小的⼀个</li>\n</ul>\n</li>\n<li>TCP的拥塞控制四种算法：<ul>\n<li>慢开始：由小到⼤逐渐增大拥塞窗⼝数值。cwnd<strong>初始值为1</strong>，每经过⼀个传播轮次，cwnd加倍</li>\n<li>拥塞避免：让拥塞窗口cwnd<strong>缓慢增大</strong>，每经过一个<strong>往返</strong>时间RTT将发送方的<strong>cwnd+1</strong></li>\n<li>快重传与快恢复：能够快速恢复丢失的数据包；<ul>\n<li>如果数据包丢失了，TCP 将会使⽤定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到⼀个不按顺序的数据段，它会⽴即给发送机发送⼀个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并⽴即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"TCP、UPD协议区别\"><a href=\"#TCP、UPD协议区别\" class=\"headerlink\" title=\"TCP、UPD协议区别\"></a>TCP、UPD协议区别</h1><p><img src=\"https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6c61ff18-12f6-403a-995d-144a288858f7/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45/20220605/us-west-2/s3/aws4_request&X-Amz-Date=20220605T133342Z&X-Amz-Expires=86400&X-Amz-Signature=395b9607457a18bb03a68588bfbf2789aae2858fb7c8c518959eeb664d3fbce6&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22&x-id=GetObject\" alt=\"TCP-UDP区别\"></p>\n<p><strong>区别如图所示：</strong></p>\n<ul>\n<li>是否面向连接</li>\n<li>可靠性</li>\n<li>数据传输形式</li>\n<li>传输效率及资源</li>\n<li>应用场景\t</li>\n<li>首部字节</li>\n</ul>\n<h1 id=\"TCP粘包\"><a href=\"#TCP粘包\" class=\"headerlink\" title=\"TCP粘包\"></a>TCP粘包</h1><p>​\t\tTCP是一个基于字节流的传输服务，”流”意味着TCP所传输的数据是没有边界的。这不同于UDP提供基于消息的传输服务，其传输的数据是有边界的。TCP的发送方无法保证对等方每次接收到的是一个完整的数据包。</p>\n<p>​\t\t粘包问题的<strong>本质就是数据读取边界错误</strong>所致。</p>\n<p><strong>产生粘包问题的原因有以下几个：</strong></p>\n<ul>\n<li>应用层调用write方法，将应用层的缓冲区中的数据拷贝到套接字的发送缓冲区。而发送缓冲区有一个SO_SNDBUF的限制，如果应用层的<strong>缓冲区数据大小大于套接字发送缓冲区的大小</strong>，则数据需要进行多次的发送。</li>\n<li>TCP所传输的报文段有MSS的限制，如果<strong>套接字缓冲区的大小大于MSS</strong>，也会导致消息的分割发送</li>\n<li>链路层最大发送单元MTU，在IP层会进行数据的分片</li>\n</ul>\n<p><strong>解决方法：</strong></p>\n<p>​\t最本质原因在与接收对等方<strong>无法分辨消息与消息之间的边界</strong>在哪。我们通过使用某种方案给出边界：</p>\n<ul>\n<li><strong>发送定长包</strong>。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息</li>\n<li><strong>包尾加上\\r\\n标记</strong>。FTP协议正是这么做的。但问题在于如果数据正文中也含有\\r\\n，则会误判为消息的边界</li>\n<li><strong>包头加上包体长度</strong>。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。</li>\n<li><strong>使用更加复杂的应用层协议</strong></li>\n</ul>\n<p><strong>参考：</strong></p>\n<p><a href=\"https://blog.csdn.net/qzcsu/article/details/72861891\">两张动图-彻底明白TCP的三次握手与四次挥手</a></p>\n<p>《图解HTTP》</p>\n","feature":true,"text":"本文内容参考链接 TCP报文内容 TCP 三次握手 三次握手过程 客户端–发送带有 SYN 标志的数据包–⼀次握⼿–服务端 服务端–发送带有 SYN&#x2F;ACK 标志的数据包–⼆次握⼿–客户端 客户端–发送带有带有 ACK 标志的数据包–三次握⼿–服务端 其中： SYN：同...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/categories/计算机网络.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":2,"path":"api/tags/计算机网络.json"},{"name":"TCP","slug":"TCP","count":1,"path":"api/tags/TCP.json"},{"name":"UDP","slug":"UDP","count":1,"path":"api/tags/UDP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TCP%E6%8A%A5%E6%96%87%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">TCP报文内容</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">TCP 三次握手</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">为什么要进行三次握手</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E\"><span class=\"toc-text\">如果已经建立了连接，但是客户端突然出现故障了怎么办</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%A0%E5%9B%9E-SYN\"><span class=\"toc-text\">为什么要传回 SYN</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E4%BA%86-SYN-%E4%B8%BA%E5%95%A5%E8%BF%98%E8%A6%81%E4%BC%A0-ACK\"><span class=\"toc-text\">传了 SYN,为啥还要传 ACK</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">TCP 四次挥手</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E7%A1%AE%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F\"><span class=\"toc-text\">为什么建立连接是三次握手，关闭连接确是四次挥手？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%872MSL%E6%89%8D%E8%BF%94%E5%9B%9E%E5%88%B0CLOSE%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">为什么TIME_WAIT状态需要经过2MSL才返回到CLOSE状态</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">TCP协议如何保证可靠传输</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E5%88%86%E6%AE%B5\"><span class=\"toc-text\">TCP分段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ARQ%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">ARQ协议</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">滑动窗口-流量控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">拥塞控制</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TCP%E3%80%81UPD%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">TCP、UPD协议区别</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TCP%E7%B2%98%E5%8C%85\"><span class=\"toc-text\">TCP粘包</span></a></li></ol>","author":{"name":"StrangerMax","slug":"blog-author","avatar":"https://biaoqingba.cn/wp-content/uploads/2019/10/6447a2207d34433.jpg","link":"/","description":"记录八股文及Go相关内容<br />学起来！！！！","socials":{"github":"https://github.com/StrangerMax","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43957499","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"数据库-查询","uid":"fdb6a521ab89f404af42557593409f9d","slug":"SQL","date":"2022-06-01T11:49:31.000Z","updated":"2022-06-02T11:36:30.185Z","comments":true,"path":"api/articles/SQL.json","keywords":null,"cover":"https://pic.3gbizhi.com/2020/0904/20200904073240878.jpg.556.308.jpg","text":" 连接查询： 内连接&#x2F;左连接&#x2F;右连接&#x2F;自关联 子查询：查询语句中包含另一个查询语句 数据库高级： 数据库ER 模型 &#x2F; 外键 &#x2F; 索引 SQL数据库通配符 通配符可用于替代字符串中的任何其他字符。 通配符 描述 % 替代 0 个或...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"SQL","slug":"SQL","count":1,"path":"api/tags/SQL.json"},{"name":"连接查询","slug":"连接查询","count":1,"path":"api/tags/连接查询.json"},{"name":"子查询","slug":"子查询","count":1,"path":"api/tags/子查询.json"},{"name":"高级","slug":"高级","count":1,"path":"api/tags/高级.json"}],"author":{"name":"StrangerMax","slug":"blog-author","avatar":"https://biaoqingba.cn/wp-content/uploads/2019/10/6447a2207d34433.jpg","link":"/","description":"记录八股文及Go相关内容<br />学起来！！！！","socials":{"github":"https://github.com/StrangerMax","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43957499","juejin":"","customs":{}}},"feature":true}}