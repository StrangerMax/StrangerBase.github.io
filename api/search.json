[{"id":"fc6990bffcc48d5be11a6070827fa5e5","title":"计算机网络-TCP","content":"本文内容参考链接\nTCP报文内容\nTCP 三次握手\n三次握手过程\n\n客户端–发送带有 SYN 标志的数据包–⼀次握⼿–服务端\n服务端–发送带有 SYN&#x2F;ACK 标志的数据包–⼆次握⼿–客户端\n客户端–发送带有带有 ACK 标志的数据包–三次握⼿–服务端\n\n其中：\n\nSYN：同步标志 同步序列编号(Synchronize Sequence Numbers)栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。\nACK：确认标志 确认编号(Acknowledgement Number)栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号(w+1，Figure-1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。\n\n为什么要进行三次握手即为什么不能用两次握手进行连接：\n\n三次握手的⽬的是建⽴可靠的通信信道，通信即数据的发送与接收，⽽三次握手最主要的⽬的就是双方确认自己与对方的发送与接收是正常的。\n改成仅需要两次握手，死锁是可能发生的\n考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组，会导致形成死锁。\n\n\n\n如果已经建立了连接，但是客户端突然出现故障了怎么办​\t\tTCP设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，就会关闭连接。\n为什么要传回 SYN​\t\t接收端传回发送端所发送的 SYN 是为了告诉发送端，接收端接收到的信息确实为发送端所发送的信号。\n传了 SYN,为啥还要传 ACK​\t\t双⽅通信⽆误必须是两者互相发送信息都⽆误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号进行验证。\nTCP 四次挥手\n四次挥手过程：\n\n客户端-发送⼀个 FIN，⽤来关闭客户端到服务器的数据传送\n\n服务器-收到这个 FIN，它返回一个 ACK，确认序号为收到的序号加1 。和 SYN⼀样，⼀个FIN将占⽤⼀个序号\n\n服务器-关闭与客户端的连接，发送⼀个FIN给客户端\n\n客户端-发回 ACK 报⽂确认，并将确认序号设置为收到序号加1\n\nFIN：结束标志\n带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据三次握手Three-way Handshake\n\n\n\n\n为什么建立连接是三次握手，关闭连接确是四次挥手？\n建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。\n而关闭连接时，服务器收到对方的FIN报文时，仅表示对方不再发送数据,但还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。\n\n为什么TIME_WAIT状态需要经过2MSL才返回到CLOSE状态\nTIME_WAIT状态用来重发可能丢失的ACK报文\n四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的：在Client发送出最后的ACK回复后，该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段，所以Client不能立即关闭，它必须确认Server接收到了该ACK。\nClient会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL\n\n\nMSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则可结束TCP连接。\n\nTCP协议如何保证可靠传输TCP主要靠以下相关机制保证其可靠传输：\n\nTCP分段：应用数据被分割成合适的TCP段发送（对UDP来说，应用程序产生的数据段长度将保持不变）\nARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停止发送，等待对方确认。在收到确认后再发下⼀个分组\n超时重传：每发出一个TCP段都会启动一个”重传定时器”；如果不能及时收到一个确认，将重传这个报文段\n\n\n流量控制：缓冲区固定大小，TCP接收端只允许另一端发送接收缓冲区所能接纳的数据（滑动窗口）\n数据校验：TCP首部(校验和)；如果收到段的校验和有差错，会选择丢弃和不确认\n拥塞控制： 当网络拥塞时，减少数据的发送\n处理数据包：a) 丢弃重复的数据包；b) 将失序的数据包重新排序后交\n\nTCP分段\n应用数据被分割成 TCP 认为最适合发送的数据块\nTCP 给发送的每⼀个包进行编号，接收方对数据包进行排序，把有序数据传送给应⽤层\nTCP 的接收端会丢弃重复的数据\n\nARQ协议\n自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之⼀。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。\n停止等待ARQ协议（超时重传）\n确认丢失：发送端重传消息，接收端丢弃重复消息，不向上层交付，重发确认ACK\n确认迟到：发送端重传消息，接收端丢弃重复消息，重发确认ACK；发送端收到重复确认丢弃第二次ACK(确认通知实际为第一次的ACK)\n\n\n连续ARQ协议\nGo-Back-N: 第N条丢失，其之后的无论是否丢失都要重传\n\n\n\n\n\n滑动窗口-流量控制TCP 利用滑动窗口实现流量控制。\n\n流量控制是为了控制发送方发送速率，保证接收方来得及接收。\n接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率\n将窗口字段设置为 0，则发送方不能发送数据\n\n\n\n拥塞控制\n拥塞：\n在某段时间，对网络中某⼀资源需求超过了该资源所能提供的可用部分，网络的性能将变坏\n\n\n拥塞控制：\n防止过多的数据注⼊到网络中，这样就可以使网络中的路由器或链路不致过载。\n前提：网络能够承受现有的网络负荷\n拥塞控制是⼀个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低⽹络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便接收端来得及接收。\n拥塞窗口（cwnd）：拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗⼝取为拥塞窗口和接收方的接受窗口中较小的⼀个\n\n\nTCP的拥塞控制四种算法：\n慢开始：由小到⼤逐渐增大拥塞窗⼝数值。cwnd初始值为1，每经过⼀个传播轮次，cwnd加倍\n拥塞避免：让拥塞窗口cwnd缓慢增大，每经过一个往返时间RTT将发送方的cwnd+1\n快重传与快恢复：能够快速恢复丢失的数据包；\n如果数据包丢失了，TCP 将会使⽤定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到⼀个不按顺序的数据段，它会⽴即给发送机发送⼀个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并⽴即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。\n\n\n\n\n\nTCP、UPD协议区别\n区别如图所示：\n\n是否面向连接\n可靠性\n数据传输形式\n传输效率及资源\n应用场景\t\n首部字节\n\nTCP粘包​\t\tTCP是一个基于字节流的传输服务，”流”意味着TCP所传输的数据是没有边界的。这不同于UDP提供基于消息的传输服务，其传输的数据是有边界的。TCP的发送方无法保证对等方每次接收到的是一个完整的数据包。\n​\t\t粘包问题的本质就是数据读取边界错误所致。\n产生粘包问题的原因有以下几个：\n\n应用层调用write方法，将应用层的缓冲区中的数据拷贝到套接字的发送缓冲区。而发送缓冲区有一个SO_SNDBUF的限制，如果应用层的缓冲区数据大小大于套接字发送缓冲区的大小，则数据需要进行多次的发送。\nTCP所传输的报文段有MSS的限制，如果套接字缓冲区的大小大于MSS，也会导致消息的分割发送\n链路层最大发送单元MTU，在IP层会进行数据的分片\n\n解决方法：\n​\t最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪。我们通过使用某种方案给出边界：\n\n发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息\n包尾加上\\r\\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\\r\\n，则会误判为消息的边界\n包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。\n使用更加复杂的应用层协议\n\n参考：\n两张动图-彻底明白TCP的三次握手与四次挥手\n《图解HTTP》\n","slug":"Web-TCP-UDP","date":"2022-06-05T10:44:37.000Z","categories_index":"","tags_index":"计算机网络,TCP,UDP","author_index":"StrangerMax"},{"id":"fdb6a521ab89f404af42557593409f9d","title":"数据库-查询","content":"\n连接查询： 内连接&#x2F;左连接&#x2F;右连接&#x2F;自关联\n子查询：查询语句中包含另一个查询语句\n数据库高级： 数据库ER 模型 &#x2F; 外键 &#x2F; 索引\n\nSQL数据库通配符\n通配符可用于替代字符串中的任何其他字符。\n\n\n\n\n通配符\n描述\n\n\n\n%\n替代 0 个或多个字符\n\n\n_\n替代一个字符\n\n\n[charlist]\n字符列中的任何单一字符\n\n\n[^charlist] 或 [!charlist]\n不在字符列中的任何单一字\n\n\n\n\n\n\n连接查询SQL 连接(JOIN)\n\nJOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段\n最简单常用的是内连接 INNER JOIN：从多个表中返回满足 JOIN 条件的所有行\n不同的JOIN\nINNER JOIN：如果表中有至少一个匹配，则返回行\nLEFT JOIN：即使右表中没有匹配，也从左表返回所有的行\nRIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行\nFULL JOIN：只要其中一个表中存在匹配，则返回行\n\n\n\n内连接\n\n内连接：查询结果为两个表匹配到的数据\nSELECT * \nFROM table1 \nINNER JOIN table2 \nON table1.column_name&#x3D;table2.column_name;\n\n注： INNER JOIN 关键字在表中存在至少一个匹配时返回行。\n\n\n左连接\n\n左连接：查询结果为两个表匹配到的数据加左表特有的数据，对于右表不存在的数据使用null\nSELECT column_name(s)\nFROM table1\nLEFT JOIN table2\nON table1.column_name&#x3D;table2.column_name;\n\n​\t   注： LEFT JOIN 关键字从左表（Websites）返回所有的行，即使右表（access_log）中没有匹配\n右连接\n\n右连接：查询结果为两个表匹配到的数据加右表特有的数据，对于左表不存在的数据使用null\nSELECT column_name(s)\nFROM table1\nRIGHT JOIN table2\nON table1.column_name&#x3D;table2.column_name;\n\n注： RIGHT JOIN 关键字从右表（access_log）返回所有的行，即使左表（Websites）中没有匹配。\n\n\n全连接\n\n全连接：只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行（注意：MySQL中不支持FULL JOIN）\nSELECT column_name(s)\nFROM table1\nFULL OUTER JOIN table2\nON table1.column_name&#x3D;table2.column_name;\n\n自关联前提：\n\n数据表只有一张\n数据表中至少有两个字段之间有某种联系\n\n方式：\n\n通过给表起别民将一张数据表变成两张，然后通过对应字段实现连接查询\n\n子查询子查询：在一个SELECT语句中，嵌入另外一个SELECT语句，嵌入的即为子查询\n子查询与主查询\n子查询是嵌入到主查询中的\n子查询是辅助主查询，要么充当条件要么充当数据源\n子查询是可以独立使用的语句，是一条完整的SELECT语句\n\n数据库设计E-R模型数据库能够有效存储现时世界中有意义的数据，通过E-R图能够更加有效的模拟现实师姐\n基本元素：实体、联系、属性\n\nE表示entry，实体：描述具有相同特征事务的抽象\n属性：每个实体的具有的各种特征为属性\nR 表示 relationship，联系：实体之间存在各种关系，关系的类型包括一对一，一对多，多对多\n\n主键与外键主键：唯一的标识一条记录，不能重复，不能为空；用来保证数据完整性\n外键：一表的属性是另一表的主键，可以重复，可以为空；用于与其他表建立联系\n索引索引：对 数据库 表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息；提高查询排序的速度\n\n优点：\n加快数据的检索速度，降低数据库的 IO 成本\n通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗\n\n\n缺点：\n占物理空间-索引文件本身很大，存储在磁盘上\n降低更新表的速度，创建和维护耗费时间，增删改查也需要进行动态维护，降低增删改查执行效率\n\n\n\n参考：\nSQL 教程 | 菜鸟教程 (runoob.com)\n","slug":"SQL","date":"2022-06-01T11:49:31.000Z","categories_index":"","tags_index":"SQL,连接查询,子查询,高级","author_index":"StrangerMax"},{"id":"da904cef7bb0ac4414b4ff066d2a6cb4","title":"Request 自动化测试","content":"Request请求方式Get\n作用 ：请求指定的页面信息，并返回实体主体；获取资源(查询)\n\n方法调用：\n\n调用get方法 r &#x3D;  request.get(“xxx”)\n\n\n参数：params：字典或字符串（推荐使用字典\n\nparams &#x3D; {“id”:1001}\nparams &#x3D; {“id”:”1001,1002”}\nparams &#x3D; {“id”:1001,”kw”:”北京”}\n\n\n响应：\n\n获取URL：r.url\n获取响应状态码:  r.status_code\n获取响应信息: r.text\n\nimport requests\n\nurl &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com&quot;\n#定义字典\n# params &#x3D; &#123;&quot;id&quot;:1001&#125;         #url : http:&#x2F;&#x2F;www.baidu.com&#x2F;?id&#x3D;1001\n# params &#x3D; &#123;&quot;id&quot;:&quot;1001,1002&quot;&#125;  #url : http:&#x2F;&#x2F;www.baidu.com&#x2F;?id&#x3D;1001%2C1002  #%2C ASCII码为逗号\nparams &#x3D; &#123;&quot;id&quot;:1001,&quot;kw&quot;:&quot;北京&quot;&#125; #url : http:&#x2F;&#x2F;www.baidu.com&#x2F;?id&#x3D;1001&amp;kw&#x3D;北京\n#请求是带参 params\nr &#x3D; requests.get(url,params &#x3D; params)  #r为响应数据对象\n\nprint(&quot;URL&quot;,r.url)\t\t\t\t   #获取URL\nprint(&quot;响应状态码&quot;,r.status_code)   #响应状态码\nprint(&quot;响应信息&quot;,r.text)\t\t\t#响应信息\n\nPost\n作用：请求服务器接受所指定的文档作为对所标识的URI的新的从属实体；\n\n方法调用：\n\n调用POST方法 requests.post(url, data&#x3D;{key: value}, json&#x3D;{key: value}, headers)\n\n\n参数：\n\nurl：URL地址 即接口\njson：请求报文（注：可用json.dumps(data),将字典对象转为json字符串）\nHeaders：请求信息头\n\n\n响应：\n\n获取响应对象： r.json()    以json文本形式响应**&lt;class ‘dict’&gt;**\n获取响应状态码:  r.status_code\n\n\n\nimport requests\n\nurl &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;login&#x2F;&quot;\n#请求headers\nheaders &#x3D; &#123;&quot;Content-Type&quot;: &quot;application&#x2F;json&quot;&#125;\n#请求json\ndata &#x3D; &#123;根据实际api文档填写&#125;\nr &#x3D; requests.post(url,json &#x3D; data, headers &#x3D; headers) \n#获取响应对象\nprint(r.json())\t\n#响应状态码   正常返回 201\nprint(r.status_code)  \n\n\n\nPut\n作用：更新资源、数据\n方法调用：\nrequests.put(url，data&#x3D;{“key”,”value”}，headers)\n\n\n参数：\n参考post方法参数\n\n\n响应：\n获取响应对象： r.json()    以json文本形式响应**&lt;class ‘dict’&gt;**\n获取响应状态码:  r.status_code\n\n\n\nDelete\n作用：删除资源\n方法调用：\nrequests.delete(url)\n\n\n参数：\n对应api\n\n\n响应：\n获取响应状态码:  r.status_code    204\n\n\n\nHead\n作用：只请求页面的首部\n方法调用：\nrequests.head(url)\n\n\n参数：\n对应api\n\n\n响应：\n获取响应状态码:  r.status_code\n\n\n\n响应内容import requests\n\nurl &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com&quot;\nr &#x3D; requests.get(url)\n\nr.encoding                #获取当前响应头部的编码\nr.encoding &#x3D; &#39;utf-8&#39;      #可设置编码\nr.text                    #以encoding解析返回内容。字符串方式的响应体，会自动根据响应头部的字符编码进行解码。\nr.url\t\t\t\t\t  #请求url\nr.content                 #以字节形式（二进制）返回。字节方式的响应体，会自动为你解码gzip和deflate压缩\n\nr.headers                 #以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回None\n\nr.status_code             #响应状态码\nr.raw                     #返回原始响应体，也就是 urllib 的 response 对象，使用 r.raw.read()   \nr.ok                      # 查看r.ok的布尔值便可以知道是否登陆成功\n\nr.cookies\t\t\t\t  #获取响应cookies信息（服务器产生）；区分统一请求客户端\n\n #*特殊方法*#\nr.json()                  #Requests中内置的JSON解码器，以json形式返回,前提返回的内容确保是json格式的，不然解析出错会抛异常\nr.raise_for_status()      #失败请求(非200响应)抛出异常\n\n\n\nSession\nSession作用：requests中的session对象能够让我们跨http请求保持某些参数\n\n即让同一个session对象发送的请求头携带某个指定的参数。\nimport requests\n \ns &#x3D; requests.Session()\n# 第一步：发送一个请求，用于设置请求中的cookies\n# tips: http:&#x2F;&#x2F;httpbin.org能够用于测试http请求和响应\ns.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#x2F;set&#x2F;sessioncookie&#x2F;123456789&#39;)\n# 第二步：再发送一个请求，用于查看当前请求中的cookies  ##携带了第一次设置的cookie\nr &#x3D; s.get(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&quot;)\nprint(r.text)\n\n##输出：\n&#123;\n  &quot;cookies&quot;: &#123;\n    &quot;sessioncookie&quot;: &quot;123456789&quot;\n  &#125;\n&#125;\n\n\n方法调用：\n\nrequests.session() \n表示一次用户会话，起始于客户端连接服务器，终止于客户端与服务器断开\n\n\n两种方式\nrequests 直接发送请求  —get&#x2F;post\nrequests.session() 发送请求.\n\n\n\n\n\n","slug":"Requests","date":"2022-05-31T13:17:18.000Z","categories_index":"","tags_index":"Request,自动化测试","author_index":"StrangerMax"},{"id":"60c63987b3ca1fdd77ae38c4f1e65abe","title":"OSI七层模型","content":"OSI七层模型OSI七层模型详解\n\n简化相关网络操作\n提供不同厂商的兼容性\n促进标准化工作\n结构上进行分层，易于学习和操作\n\n分层1.物理层 ：\n2.数据链路层\n3.网络层\n4.传输层\n5.会话层\n6.表示层\n7.应用层\n物理层","slug":"Web-OSI","date":"2022-05-28T12:04:57.000Z","categories_index":"","tags_index":"计算机网络,OSI","author_index":"StrangerMax"}]