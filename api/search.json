[{"id":"fdb6a521ab89f404af42557593409f9d","title":"数据库-查询","content":"\n连接查询： 内连接&#x2F;左连接&#x2F;右连接&#x2F;自关联\n子查询：查询语句中包含另一个查询语句\n数据库高级： 数据库ER 模型 &#x2F; 外键 &#x2F; 索引\n\nSQL数据库通配符\n通配符可用于替代字符串中的任何其他字符。\n\n\n\n\n通配符\n描述\n\n\n\n%\n替代 0 个或多个字符\n\n\n_\n替代一个字符\n\n\n[charlist]\n字符列中的任何单一字符\n\n\n[^charlist] 或 [!charlist]\n不在字符列中的任何单一字\n\n\n\n\n\n\n连接查询SQL 连接(JOIN)\n\nJOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段\n最简单常用的是内连接 INNER JOIN：从多个表中返回满足 JOIN 条件的所有行\n不同的JOIN\nINNER JOIN：如果表中有至少一个匹配，则返回行\nLEFT JOIN：即使右表中没有匹配，也从左表返回所有的行\nRIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行\nFULL JOIN：只要其中一个表中存在匹配，则返回行\n\n\n\n内连接\n\n内连接：查询结果为两个表匹配到的数据\nSELECT * \nFROM table1 \nINNER JOIN table2 \nON table1.column_name&#x3D;table2.column_name;\n\n注： INNER JOIN 关键字在表中存在至少一个匹配时返回行。\n\n\n左连接\n\n左连接：查询结果为两个表匹配到的数据加左表特有的数据，对于右表不存在的数据使用null\nSELECT column_name(s)\nFROM table1\nLEFT JOIN table2\nON table1.column_name&#x3D;table2.column_name;\n\n​\t   注： LEFT JOIN 关键字从左表（Websites）返回所有的行，即使右表（access_log）中没有匹配\n右连接\n\n右连接：查询结果为两个表匹配到的数据加右表特有的数据，对于左表不存在的数据使用null\nSELECT column_name(s)\nFROM table1\nRIGHT JOIN table2\nON table1.column_name&#x3D;table2.column_name;\n\n注： RIGHT JOIN 关键字从右表（access_log）返回所有的行，即使左表（Websites）中没有匹配。\n\n\n全连接\n\n全连接：只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行（注意：MySQL中不支持FULL JOIN）\nSELECT column_name(s)\nFROM table1\nFULL OUTER JOIN table2\nON table1.column_name&#x3D;table2.column_name;\n\n自关联前提：\n\n数据表只有一张\n数据表中至少有两个字段之间有某种联系\n\n方式：\n\n通过给表起别民将一张数据表变成两张，然后通过对应字段实现连接查询\n\n子查询子查询：在一个SELECT语句中，嵌入另外一个SELECT语句，嵌入的即为子查询\n子查询与主查询\n子查询是嵌入到主查询中的\n子查询是辅助主查询，要么充当条件要么充当数据源\n子查询是可以独立使用的语句，是一条完整的SELECT语句\n\n数据库设计E-R模型数据库能够有效存储现时世界中有意义的数据，通过E-R图能够更加有效的模拟现实师姐\n基本元素：实体、联系、属性\n\nE表示entry，实体：描述具有相同特征事务的抽象\n属性：每个实体的具有的各种特征为属性\nR 表示 relationship，联系：实体之间存在各种关系，关系的类型包括一对一，一对多，多对多\n\n主键与外键主键：唯一的标识一条记录，不能重复，不能为空；用来保证数据完整性\n外键：一表的属性是另一表的主键，可以重复，可以为空；用于与其他表建立联系\n索引索引：对 数据库 表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息；提高查询排序的速度\n\n优点：\n加快数据的检索速度，降低数据库的 IO 成本\n通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗\n\n\n缺点：\n占物理空间-索引文件本身很大，存储在磁盘上\n降低更新表的速度，创建和维护耗费时间，增删改查也需要进行动态维护，降低增删改查执行效率\n\n\n\n参考：\nSQL 教程 | 菜鸟教程 (runoob.com)\n","slug":"SQL","date":"2022-06-01T11:49:31.000Z","categories_index":"","tags_index":"SQL,连接查询,子查询,高级","author_index":"StrangerMax"},{"id":"da904cef7bb0ac4414b4ff066d2a6cb4","title":"Request 自动化测试","content":"RequestGet方法\n作用 ：请求指定的页面信息，并返回实体主体；获取资源(查询)\n\n方法调用：\n\n调用get方法 r &#x3D;  request.get(“xxx”)\n\n\n响应对象\n\n获取URL：r.url\n获取响应状态码:  r.status_code\n获取响应信息: r.text\n\n\n请求带参\n\n参数：params：字典或字符串（推荐使用字典\nparams &#x3D; {“id”:1001}\nparams &#x3D; {“id”:”1001,1002”}\nparams &#x3D; {“id”:1001,”kw”:”北京”}\n\n\n\nimport requests\n\nurl &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com&quot;\n#定义字典\n# params &#x3D; &#123;&quot;id&quot;:1001&#125;         #url : http:&#x2F;&#x2F;www.baidu.com&#x2F;?id&#x3D;1001\n# params &#x3D; &#123;&quot;id&quot;:&quot;1001,1002&quot;&#125;  #url : http:&#x2F;&#x2F;www.baidu.com&#x2F;?id&#x3D;1001%2C1002  #%2C ASCII码为逗号\nparams &#x3D; &#123;&quot;id&quot;:1001,&quot;kw&quot;:&quot;北京&quot;&#125; #url : http:&#x2F;&#x2F;www.baidu.com&#x2F;?id&#x3D;1001&amp;kw&#x3D;北京\n#请求是带参 params\nr &#x3D; requests.get(url,params &#x3D; params)  #r为响应数据对象\n\nprint(&quot;URL&quot;,r.url)\t\t\t\t   #获取URL\nprint(&quot;响应状态码&quot;,r.status_code)   #响应状态码\nprint(&quot;响应信息&quot;,r.text)\t\t\t#响应信息\n\nPOST请求\n作用：请求服务器接受所指定的文档作为对所标识的URI的新的从属实体；\n\n方法调用：\n\n调用POST方法 requests.post(url, data&#x3D;{key: value}, json&#x3D;{key: value}, headers)\n\n\n参数：\n\nurl：URL地址 即接口\njson：请求报文\nHeaders：请求信息头\n\n\n响应对象\n\n获取响应对象： r.json()    以json文本形式响应\n获取响应状态码:  r.status_code\n\n\n\nimport requests\n\nurl &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;login&#x2F;&quot;\n#请求headers\nheaders &#x3D; &#123;&quot;Content-Type&quot;: &quot;application&#x2F;json&quot;&#125;\n#请求json\ndata &#x3D; &#123;根据实际api文档填写&#125;\nr &#x3D; requests.post(url,json &#x3D; data, headers &#x3D; headers) \n#获取响应对象\nprint(r.json())\t\n#响应状态码   正常返回 201\nprint(r.status_code)  \n\n","slug":"python-request","date":"2022-05-31T13:17:18.000Z","categories_index":"","tags_index":"Request,自动化测试","author_index":"StrangerMax"},{"id":"60c63987b3ca1fdd77ae38c4f1e65abe","title":"OSI七层模型","content":"OSI七层模型OSI七层模型详解\n\n简化相关网络操作\n提供不同厂商的兼容性\n促进标准化工作\n结构上进行分层，易于学习和操作\n\n分层1.物理层 ：\n2.数据链路层\n3.网络层\n4.传输层\n5.会话层\n6.表示层\n7.应用层\n物理层","slug":"Web-OSI","date":"2022-05-28T12:04:57.000Z","categories_index":"","tags_index":"计算机网络,OSI","author_index":"StrangerMax"},{"id":"fc6990bffcc48d5be11a6070827fa5e5","title":"计算机网络-TCP","content":"本文内容参考链接\nTCP报文内容\nTCP 三次握手\n三次握手过程\n\n客户端–发送带有 SYN 标志的数据包–⼀次握⼿–服务端\n服务端–发送带有 SYN&#x2F;ACK 标志的数据包–⼆次握⼿–客户端\n客户端–发送带有带有 ACK 标志的数据包–三次握⼿–服务端\n\n其中：\n\nSYN：同步标志 同步序列编号(Synchronize Sequence Numbers)栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。\nACK：确认标志 确认编号(Acknowledgement Number)栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号(w+1，Figure-1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。\n\n为什么要进行三次握手即为什么不能用两次握手进行连接：\n\n三次握手的⽬的是建⽴可靠的通信信道，通信即数据的发送与接收，⽽三次握⼿最主要的⽬的就是双方确认自己与对方的发送与接收是正常的。\n改成仅需要两次握手，死锁是可能发生的\n考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组，会导致形成死锁。\n\n\n\n如果已经建立了连接，但是客户端突然出现故障了怎么办​\t\tTCP设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，就会关闭连接。\n为什么要传回 SYN​\t\t接收端传回发送端所发送的 SYN 是为了告诉发送端，接收端接收到的信息确实为发送端所发送的信号。\n传了 SYN,为啥还要传 ACK​\t\t双⽅通信⽆误必须是两者互相发送信息都⽆误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号进行验证。\n","slug":"Web-TCP-UDP","date":"2022-05-28T10:44:37.000Z","categories_index":"","tags_index":"计算机网络,TCP,UDP","author_index":"StrangerMax"}]