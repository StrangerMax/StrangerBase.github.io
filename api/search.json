[{"id":"da904cef7bb0ac4414b4ff066d2a6cb4","title":"Request 自动化测试","content":"Get方法\n作用 ：获取资源(查询)\n步骤：\n导包 import requests\n调用get方法 r &#x3D;  request.get(“xxx”)\n\n\n响应对象\n获取URL：r.url\n获取响应状态码:  r.status_code\n获取响应信息: r.text\n\n\n\n","slug":"python-request","date":"2022-05-31T13:17:18.000Z","categories_index":"","tags_index":"Request,自动化测试","author_index":"StrangerMax"},{"id":"60c63987b3ca1fdd77ae38c4f1e65abe","title":"OSI七层模型","content":"OSI七层模型OSI七层模型详解\n\n简化相关网络操作\n提供不同厂商的兼容性\n促进标准化工作\n结构上进行分层，易于学习和操作\n\n分层1.物理层 ：\n2.数据链路层\n3.网络层\n4.传输层\n5.会话层\n6.表示层\n7.应用层\n物理层","slug":"Web-OSI","date":"2022-05-28T12:04:57.000Z","categories_index":"","tags_index":"计算机网络,OSI","author_index":"StrangerMax"},{"id":"fc6990bffcc48d5be11a6070827fa5e5","title":"计算机网络-TCP","content":"本文内容参考链接\nTCP报文内容\nTCP 三次握手\n三次握手过程\n\n客户端–发送带有 SYN 标志的数据包–⼀次握⼿–服务端\n服务端–发送带有 SYN&#x2F;ACK 标志的数据包–⼆次握⼿–客户端\n客户端–发送带有带有 ACK 标志的数据包–三次握⼿–服务端\n\n其中：\n\nSYN：同步标志 同步序列编号(Synchronize Sequence Numbers)栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。\nACK：确认标志 确认编号(Acknowledgement Number)栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号(w+1，Figure-1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。\n\n为什么要进行三次握手即为什么不能用两次握手进行连接：\n\n三次握手的⽬的是建⽴可靠的通信信道，通信即数据的发送与接收，⽽三次握⼿最主要的⽬的就是双方确认自己与对方的发送与接收是正常的。\n改成仅需要两次握手，死锁是可能发生的\n考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组，会导致形成死锁。\n\n\n\n如果已经建立了连接，但是客户端突然出现故障了怎么办​\t\tTCP设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，就会关闭连接。\n为什么要传回 SYN​\t\t接收端传回发送端所发送的 SYN 是为了告诉发送端，接收端接收到的信息确实为发送端所发送的信号。\n传了 SYN,为啥还要传 ACK​\t\t双⽅通信⽆误必须是两者互相发送信息都⽆误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号进行验证。\n","slug":"Web-TCP-UDP","date":"2022-05-28T10:44:37.000Z","categories_index":"","tags_index":"计算机网络,TCP,UDP","author_index":"StrangerMax"},{"id":"e560c4455a9092ea4e503020d97b7475","title":"数据库-连接查询","content":"\n连接查询： 内连接&#x2F;左连接&#x2F;右连接&#x2F;自关联\n子查询：查询语句中包含另一个查询语句\n数据库高级： 数据库ER 模型 &#x2F; 外键 &#x2F; 索引\n\nSQL语句SQL 连接(JOIN)\n\nJOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段\n最简单常用的是内连接 INNER JOIN：从多个表中返回满足 JOIN 条件的所有行\n不同的JOIN\nINNER JOIN：如果表中有至少一个匹配，则返回行\nLEFT JOIN：即使右表中没有匹配，也从左表返回所有的行\nRIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行\nFULL JOIN：只要其中一个表中存在匹配，则返回行\n\n\n\n连接查询内连接​                                                                                                               \n\n内连接：查询结果为两个表匹配到的数据\nSELECT * \nFROM table1 \nINNER JOIN table2 \nON table1.column_name&#x3D;table2.column_name;\n\n注： INNER JOIN 关键字在表中存在至少一个匹配时返回行。\n\n\n左连接​                                                                                                              \n\n左连接：查询结果为两个表匹配到的数据加左表特有的数据，对于右表不存在的数据使用null\nSELECT column_name(s)\nFROM table1\nLEFT JOIN table2\nON table1.column_name&#x3D;table2.column_name;\n\n​\t   注： LEFT JOIN 关键字从左表（Websites）返回所有的行，即使右表（access_log）中没有匹配\n右连接​                                                                                                              \n\n右连接：查询结果为两个表匹配到的数据加右表特有的数据，对于左表不存在的数据使用null\nSELECT column_name(s)\nFROM table1\nRIGHT JOIN table2\nON table1.column_name&#x3D;table2.column_name;\n\n注： RIGHT JOIN 关键字从右表（access_log）返回所有的行，即使左表（Websites）中没有匹配。\n\n\n","slug":"SQL","date":"2022-06-01T11:49:31.000Z","categories_index":"","tags_index":"SQL,连接查询，数据库，子查询","author_index":"StrangerMax"},{"id":"d9310819751f9d553253529bb6c0b98e","title":"Go-Mutex","content":"1\n","slug":"Go-Mutex","date":"2022-05-28T12:04:43.000Z","categories_index":"","tags_index":"Golang","author_index":"StrangerMax"},{"id":"b391db8e886fb3d55f625ef3bf7105ae","title":"golang-pre","content":"GO并发Channel待完善\n","slug":"golang-pre","date":"2022-05-27T12:58:06.000Z","categories_index":"","tags_index":"golang","author_index":"StrangerMax"}]